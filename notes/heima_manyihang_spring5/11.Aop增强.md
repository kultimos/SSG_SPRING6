# Aop增强的方式

  ## aspectj编译器(使用较少,知道即可)
  - 需要引入aspectj的依赖插件,通过该插件对代码进行编译,编译后的结果会将涉及aop的部分进行代码的重写,从而实现无需通过spring的代理,就可以实现aop
  的功能增强;

  ## agent类加载(使用较少,知道即可)
  - 通过添加JVM启动参数: [-javaagent:D:/professional_package_jar/maven/maven_res/org/aspectj/aspectjweaver/1.9.7/aspectjweaver-1.9.7.jar],
  其占用[D:/professional_package_jar/maven/maven_res]为maven仓库地址
  - 通过该参数也可以实现Aop的增强

  ## jdk动态代理实现Aop增强
  
  ### jdk动态代理实现Aop的代码演示
  - [](/spring5/src/main/java/com/kul/a11/JdkProxyDemo.java)

  ### 手写jdk动态代理源码
  - [](/spring5/src/main/java/com/kul/a12/$Proxy0.java)、[](/spring5/src/main/java/com/kul/a12/A12.java)

  ### Aop与动态代理之间的关系
  - 当在一个类上使用@Aspect注解时,Spring会在启动时扫描该类,并将其注册为一个切面
  - Spring利用AspectAutoProxyCreator这个类来实现切面与JDK动态代理之间的关联,该类会对每个被Bean管理的类进行一次判断,是否需要代理(是否应用了切面),
  如果该Bean需要被代理,则会创建一个代理对象来替代目标Bean,如果该目标类实现了接口,则使用JDK动态代理,否则使用CGLIB动态代理

  ### jdk动态代理原理(结合老师的讲解,个人的理解)
  - 所谓代理,就是要通过一个代理对象来去实现最终的方法的调用,所以我们需要一个代理对象来继承我们的目标类对象,通过重写其目标方法,在我们代理对象中进行方法的重写,
  实现功能的增强;
  - 但是对于一个可用的代理对象来说,它要如何去增强我们的目标方法,这个事情是动态的,而不应该是在代码中写死的,所以我们需要在创建代理对象时把我们想要增强的逻辑,传递
  进去,那么传递的这个,落实下来,就是一个InvocationHandler;我们需要在代理对象中,创建一个InvocationHandler属性,用来确定要增强的逻辑
  - 进而,在InvocationHandler中通过指定想要进行增强的方法名和参数,来实现一个外部配置方法名、方法参数和要增强的逻辑,最终交由我们代理对象实现对目标对象方法的调用和
  增强;
  - JDK动态代理的核心: 类加载器,一组需要实现的接口,就是为了让代理类继承接口,好方便后续对这些方法进行"重写增强";
    - 类加载器: 简单说,jdk动态代理之所以需要一个classloader,就是为了动态的生成一个代码编译时并不存在的代理类的字节码文件,即我们自己手写的Proxy的字节码文件
    - 一组要实现的接口
    - 拦截器,拦截器的参数是代理对象,目标方法和方法参数,在拦截器中我们可以实现对目标方法的增强,也是在这通过反射实现了方法的反射调用;

  ## cglib动态代理实现Aop增强

  ### cglib代理实现Aop增强的代码演示
  - [](/spring5/src/main/java/com/kul/a11/CglibProxyDemo.java)

  ### 手写chlib动态代理源码
  - [](/spring5/src/main/java/com/kul/a12/$Proxy0.java)

  ### cglib如何通过MethodProxy避免反射调用方法及原理
  - cglib在动态代理时会产生两个代理类(TargetFastClass、ProxyFastClass)和一个代理对象(ProxyClass)
  - 代理对象通过继承目标对象的方式,继承了其多个方法,并进行了methodSuper(super.method())的不增强式代码重写和method(invoke())的反射式代码重写,其中第二种跟jdk类似,
  通过反射的方式实现调用,而第一种就是为了以后的对象代理类来调用;
  - cglib为我们提供了三种实现代理的方式,分别是method.invoke(target, args)、methodProxy.invoke(target, args)和methodProxy.invokeSuper(proxy, args);
  其中第一种实际上跟jdk的动态代理逻辑是相似的,通过反射实现方法的调用,而后两种才是cglib与jdk区别之处
  - cglib在使用时会针对目标类生成两个代理类,一个是目标代理类,一个是对象代理类,这两个类对应着invoke(target, args)和invokeSuper(proxy, args)的使用,如果希望使用
  目标对象,则会在目标对象代理类中直接调用目标对象的方法,从而避免了反射;代理对象则是会在代理对象类中调用代理对象的super方法,也是避免了反射;
  - method.invoke(target, args),传入了目标对象和参数,ok,那么通过method和args信息,methodProxy就可以确定你当前调用的是哪个方法,所以最终在TargetFastClass的代理
  类中,就可以通过((Target) target).save();的方式实现调用;method.invokeSuper(proxy, args)也是一样,最终通过(($Proxy1) target).saveSuper();

  ## 简单的比较
  - jdk动态代理在代理方法处需要通过反射调用,性能会有所下降
  - cglib动态代理虽然在代理方法处可以不使用反射,性能较高;但在创建代理对象时,需要生产更多的代理类,所以在创建代理对象时性能较低
  - jdk代理的类必须要实现接口,spring主要还是通过是否实现接口来选择代理方式,实现了就是jdk动态代理,否则就选用cglib动态代理