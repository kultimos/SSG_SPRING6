# AOP
  ## Spring中AOP的实现方式
  - 通过execution表达式
  - 通过@PointCut定义切入点
  - 通过注解实现aop的代码演示: [](/spring5/src/main/java/com/kul/a15/aop/MyAspect.java)
  - 通过代码实现aop的代码演示: [](/spring5/src/main/java/com/kul/a15/A15.java)

  ## 延伸下@Transactional注解使用的一些tips
  - 可以加在类上,表示该类的所有方法都会被事务增强
  - 如果方法上,类上均没有@Transactional注解,但继承的接口被@Transactional注解修饰了,则该类中所有的继承自该接口的方法也都会被事务增强

  ## @Advisor与@Aspect
  - @Aspect切面中可以有多组通知跟切点
  - @Advisor切面中只可以有一组通知和切点
  - 对于@Aspect的高级切面来说,我们可以通过@Order(1)这种方式来选择需要优先进行增强的切面,而@Advisor的低级切面无法识别@Order注解,
  但可以通过setOrder的方式调整优先级,代码演示: [](/spring5/src/main/java/com/kul/a17/A17.java)
  - 但需要注意,@Order注解仅对切面有效,而无法具体到切面内的某个切入点上,所以如果一个高级切面内有多个切入点,比如两个@Before增强,如果我们希望这两个
  增强有先后顺序的话,就只能把这两个切入点分别写到两个不同的切面,否则在同一个切面中,我们无法控制其执行的顺序

  ## AnnotationAwareAspectJAutoProxyCreator
  - 一个bean后置处理器,用于处理所有的切面类,根据切面信息,最终创建代理对象;
  - 该后处理器中有两个核心方法,findEligibleAdvisors()用于获取低级切面的List集合,wrapIfNecessary()会根据上一步获取到的切面集合来判断当前目标类
  是否因为切面,从而需要创建一个代理对象来增强,只要该集合不为空,则需要创建代理; 代码演示: [](/spring5/src/main/java/com/kul/a17/A17.java)
  - 因为最终是一个低级切面的List集合,所以这个过程中实际上还包含着高级切面转换为低级切面这样一个动作,见代码: [](/spring5/src/main/java/com/kul/a17/A17_2.java)
  - 而创建代理对象的流程,实际上就是通过解析切面信息和切入点以及advice信息,最终通过一个代理工厂最终创建出代理对象,
  代码演示:[](/spring5/src/main/java/com/kul/a15/A15.java)

  ## 静态通知调用————多类型通知统一转为MethodInterceptor类型的环绕通知
  - 可以发现我们在[](/spring5/src/main/java/com/kul/a15/A15.java)和[](/spring5/src/main/java/com/kul/a17/A17_2.java)中,对于创建切面时的advice的
  实现方式是不同的,一个是通过重写MethodInterceptor的invoke()方法,而一个是通过创建AspectJMethodBeforeAdvice对象,那为什么有多做写法,二者之间有何联系呢？
  - AspectJMethodBeforeAdvice对象是由@Before注解转换来的,类似对象的还有:
    - AspectJAroundAdvice(环绕通知)
    - AspectJAfterReturningAdvice(正常返回通知)
    - AspectJAfterThrowingAdvice(异常通知)
    - AspectJAfterAdvice(后置通知)
  - 而上述的这些对象,在最终执行之前都会转为MethodInterceptor的环绕通知

  ### 为什么我们要把多种通知最终统一改为环绕通知呢？
  - 可以根据代码的运行结果来进行分析: [](/spring5/src/main/java/com/kul/a17/A17.java)
  - 运行后可以看到运行结果是这样的:
    - aspect1 before ...  (第一个切面的前置增强)
    - advice3 before ...  (第二个切面的前置增强)
    - target1 foo         (目标原始方法)
    - advice3 after ...   (第二个切面的后置增强)
    - aspect1 after ...   (第一个切面的后置增强)
  - 可以看到,执行完第一个切面的前置增强后,他并不是立刻去执行目标方法和后置增强,而是会继续找当前这个目标类是否还有其他切面,切面上是否还有其他前置增强,
  如果有,则去执行下一个切面的前置增强方法;并且在执行完目标类方法以后,是找最近一次执行的切面,进而执行其后置增强,类似于套娃,而这种现象就是因为我们把多
  哥个不同类型的增强都转为了环绕增强(环绕通知),而这个转换的过程,其实也是Spring中应用设计模式的一个典型案例: 适配器模式,对外为了方便实用,要区分通知
  类型,即我们可以通过使用不同的注解:@Before、@AfterReturning来区分,但对内都是环绕通知,统一用MethodInterceptor来表示
  - 代码演示通知归一化的流程: [](/spring5/src/main/java/com/kul/a18/A18.java)

  ## 调用链————创建并执行调用链(环绕通知 + 目标方法)
  - 代码实例: [](/spring5/src/main/java/com/kul/a18/A18_2.java)

  # AOP总结
     
  ## 1.代理方式的选择
  - 底层是应用了动态代理的原理,通过创建代理对象,实现了功能的增强;具体选用JDK动态代理还是cglib动态代理,需要看该目标类是否实现了接口,如果实现了接
  口,则应用jdk动态代理,否则应用cglib动态代理;其实还有一种情况,即使目标类实现了接口,依然会选用cglib动态代理;这种情况就是当Spring的ProxyFactory
  工厂类的属性proxyTargetClass为true时,目标类就一定会用cglib动态代理,不过因为这个属性默认为false,所以简单地说认为是否实现接口就能判断代理类型
  也是可以的;

  ## 2.切面的解析
  
  ## 2.1 切点的解析
  - 无论是直接使用[ @Before("execution(* perform())") ]或是[ @Pointcut("execution(* perform())") ],我们都需要明确指明要进行增强的
  目标方法表达式,这是第一步,获取切点

  ## 2.2 准备切面
  - 简单说,这里是在底层真实的建立了切面,切面中包含切点和通知;这里我们会创建多个切面,对应不同的切点和不同的通知(功能增强);

  ## 2.2.1 切面转换
  - 我们常用的@Aspect是一种高级切面,即一个切面中可以定义多个切面方法,也可以说是多个通知(@Before、@After、@AfterReturning)和多个切点,而对于
  低级切面Advisor,一个切面中只包含一个切点和一个增强(切面方法、通知);所以在底层,实际上有一个高级切面向低级切面转换的过程,这一步将粒度变得更细,方
  便之后的操作;

  ## 2.2.2 通知转换
  - 我们在代码中可能会写为前置通知,或者是后置通知,但是在底层都会统一转为环绕通知

  ## 2.2.3 引用链创建
  - 所谓引用链的创建,就是通过在Invocation的proceed()中通过对切面集合的监控和遍历,完成所有切面的功能增强;这一步是通过递归来完成的,很巧妙
  - 在Invocation的proceed()方法中只统计调用了的切面的个数,一旦个数达到切面集合的size(),说明所有切面都已经执行完毕,此时去执行目标方法即可;
  而如果,还没有达到size,则重切面list中取出一个切面,反射调用其invoke()方法,而在invoke()方法中,又一定会调用Invocation的proceed()方法,通过
  这种方式实现了代理对象和一系列切面信息的引用链的创建;
 
  ## 2.3 创建代理对象
  - 创建代理对象依赖于切面信息,即只有在切面集合不为空时,才会创建代理对象;
  - 创建代理对象时需要将切面信息、目标类信息、写入代理对象;
  - 这样后续调用目标对象方法时,实际上是调用代理对象,则进入了增强逻辑;




















